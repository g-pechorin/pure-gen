
package foo.bar {

	import peterlavalle.puregen.Cyclist

	/**
	 * this is the "real" base type you should extend
	 */
	trait A {
		this: B => // we're no good without the mixin


		val OpaqueTest: OpaqueTest
	}

	/**
	 * this mixin functionality connects to the scripting
	 */
	trait B {
		this: A =>

		val bike: Cyclist // give me this - so that i can implement some things for you

		import peterlavalle.puregen._
		import org.graalvm.polyglot._
		import scala.reflect.ClassTag

		// hackey solution to getting samples in
		def s[I: ClassTag](sample: TModule.Sample[I]): (() => Any)

		// hackey solution to getting events in
		def e[I: ClassTag](event: TModule.Event[I]): (() => Any)

		// hackey solution to getting signals out
		def o[O: ClassTag](signal: TModule.Signal[O]): (Any => Unit)

		/**
		 * puts the module's stuff into the JS context
		 */
		def apply(context: Context): Context =
			context
				.global[Unit, () => Any]("OpaqueTest.Mike") {
					_: Unit =>
						import this.OpaqueTest._
						e[Audio](this.OpaqueTest.openMike())
				}
	}

	/**
	 * this is a helper base type that is missing functionality
	 */
	abstract class C extends A with B {
		override lazy val OpaqueTest: OpaqueTest = peterlavalle.error("OpaqueTest has not been implemented")
	}
}
