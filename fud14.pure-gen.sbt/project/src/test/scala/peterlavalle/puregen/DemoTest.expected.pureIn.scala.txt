
package foo.bar {

	import peterlavalle.puregen.Cyclist

	/**
	 * this is the "real" base type you should extend
	 */
	trait A {
		this: B => // we're no good without the mixin


		val DemoTest: DemoTest
	}

	/**
	 * this mixin functionality connects to the scripting
	 */
	trait B {
		this: A =>

		val bike: Cyclist // give me this - so that i can implement some things for you

		import peterlavalle.puregen._
		import org.graalvm.polyglot._
		import scala.reflect.ClassTag

		// hackey solution to getting samples in
		def s[I: ClassTag](sample: TModule.Sample[I]): (() => Any)

		// hackey solution to getting events in
		def e[I: ClassTag](event: TModule.Event[I]): (() => Any)

		// hackey solution to getting signals out
		def o[O: ClassTag](signal: TModule.Signal[O]): (Any => Unit)

		/**
		 * puts the module's stuff into the JS context
		 */
		def apply(context: Context): Context =
			context
				.global[Unit, () => Any]("DemoTest.Age") {
					_: Unit =>
						import this.DemoTest._
						s[Float](this.DemoTest.openAge())
				}
				.global[Unit, () => Any]("DemoTest.Eve") {
					_: Unit =>
						import this.DemoTest._
						e[String](this.DemoTest.openEve())
				}
				.global[Unit, Any => Unit]("DemoTest.Kick") {
					_: Unit =>
						import this.DemoTest._
						o[Float](this.DemoTest.openKick())
				}
				.global[String, Any => Unit]("DemoTest.Status") {
					(a0: String) =>
						import this.DemoTest._
						o[String](this.DemoTest.openStatus(a0))
				}
	}

	/**
	 * this is a helper base type that is missing functionality
	 */
	abstract class C extends A with B {
		override lazy val DemoTest: DemoTest = peterlavalle.error("DemoTest has not been implemented")
	}
}
